package com.moneyos

import android.content.BroadcastReceiver
import android.content.Context
import android.content.Intent
import android.provider.Telephony
import android.util.Log
import org.json.JSONObject
import java.net.HttpURLConnection
import java.net.URL
import java.text.SimpleDateFormat
import java.util.*
import kotlin.concurrent.thread

/**
 * MoneyOS Android SMS Bridge
 * Intercepts banking SMS and pushes them to the Railway backend.
 * Place this in: android/app/src/main/java/com/moneyos/SmsReceiver.kt
 */
class SmsReceiver : BroadcastReceiver() {
    override fun onReceive(context: Context, intent: Intent) {
        if (intent.action == Telephony.Sms.Intents.SMS_RECEIVED_ACTION) {
            val messages = Telephony.Sms.Intents.getMessagesFromIntent(intent)
            for (sms in messages) {
                val body = sms.displayMessageBody
                val sender = sms.displayOriginatingAddress
                processSms(context, body, sender ?: "Unknown")
            }
        }
    }

    private fun processSms(context: Context, body: String, sender: String) {
        val lowerBody = body.lowercase()
        
        // 1. Transactional check
        val isTransactional = lowerBody.contains("rs.") || 
                              lowerBody.contains("inr") || 
                              lowerBody.contains("₹") ||
                              lowerBody.contains("debited") ||
                              lowerBody.contains("credited") ||
                              lowerBody.contains("paid") ||
                              lowerBody.contains("received")

        if (!isTransactional) return

        // 2. Load Configuration (Stored by React Native side in SharedPreferences)
        // You'll need to use a RN library to write to "MoneyOS_Config" or use a NativeModule
        val prefs = context.getSharedPreferences("MoneyOS_Config", Context.MODE_PRIVATE)
        val apiUrl = prefs.getString("apiUrl", "https://sms-backend-production-cad9.up.railway.app")
        val userId = prefs.getString("userId", null)
        val secret = prefs.getString("secret", null)
        val isActive = prefs.getBoolean("isActive", true)

        if (!isActive || userId == null || secret == null) {
            Log.d("MoneyOS", "Bridge inactive or config missing. Sync skipped.")
            return
        }

        // 3. Threaded network push
        thread {
            try {
                val transaction = extractTxInfo(body, sender) ?: return@thread
                
                val url = URL("$apiUrl/api/transactions/push")
                val conn = url.openConnection() as HttpURLConnection
                conn.requestMethod = "POST"
                conn.setRequestProperty("Content-Type", "application/json")
                conn.setRequestProperty("x-moneyos-secret", secret)
                conn.setRequestProperty("x-user-id", userId)
                conn.doOutput = true

                val jsonBody = JSONObject()
                val txJson = JSONObject()
                txJson.put("id", transaction.id)
                txJson.put("hash", transaction.hash)
                txJson.put("type", transaction.type)
                txJson.put("amount", transaction.amount)
                txJson.put("category", transaction.category)
                txJson.put("description", transaction.description)
                txJson.put("date", transaction.date)
                txJson.put("firewallDecision", "ALLOW")
                txJson.put("firewallReason", "Edge-Native Intercept")

                jsonBody.put("transaction", txJson)

                conn.outputStream.use { it.write(jsonBody.toString().toByteArray()) }

                val code = conn.responseCode
                Log.d("MoneyOS", "Push Status: $code for ${transaction.amount} at ${transaction.description}")
            } catch (e: Exception) {
                Log.e("MoneyOS", "Push Error", e)
            }
        }
    }

    private fun extractTxInfo(body: String, sender: String): SimpleTx? {
        val amountRegex = Regex("(?:rs\\.?|inr|₹)\\s*([\\d,]+(?:\\.\\d{1,2})?)", RegexOption.IGNORE_CASE)
        val match = amountRegex.find(body) ?: return null
        
        val amount = match.groupValues[1].replace(",", "").toDoubleOrNull() ?: return null
        val isCredit = body.lowercase().contains("credited") || body.lowercase().contains("received")
        val type = if (isCredit) "CREDIT" else "DEBIT"
        
        val sdf = SimpleDateFormat("yyyy-MM-dd", Locale.US)
        val date = sdf.format(Date())
        
        // Simple hash for dedup
        val hash = Integer.toHexString("${amount}${sender}${date}".hashCode())

        return SimpleTx(
            id = hash,
            hash = hash,
            type = type,
            amount = amount,
            category = if (isCredit) "Income" else "Uncategorized",
            description = sender,
            date = date
        )
    }

    data class SimpleTx(
        val id: String,
        val hash: String,
        val type: String,
        val amount: Double,
        val category: String,
        val description: String,
        val date: String
    )
}